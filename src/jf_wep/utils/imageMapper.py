"""Class that maps the pupil to the image plane, and vice versa.

This is used in the TIE and Danish algorithms.
"""
from pathlib import Path
from typing import Optional, Tuple, Union

import numpy as np
from scipy.interpolate import griddata, interpn

from jf_wep.donutStamp import DonutStamp
from jf_wep.instrument import Instrument
from jf_wep.utils.enums import DefocalType
from jf_wep.utils.paramReaders import loadConfig, mergeParams
from jf_wep.utils.zernikes import zernikeGradEval


class ImageMapper:
    """Class for mapping the pupil to the image plane, and vice versa.

    Parameters
    ----------
    configFile : Path or str, optional
        Path to file specifying values for the other parameters. If the
        path starts with "policy/", it will look in the policy directory.
        Any explicitly passed parameters override values found in this file
        (the default is policy/utils/imageMapper.yaml)
    opticalModel : str, optional
        The optical model used for image compensation. If "paraxial", the
        original algorithm from Rodier & Rodier (1993) is used, which is
        suitable for images near the optical axis on telescope with large
        focal ratios. If "onAxis", the modification for small focal ratios
        (i.e. fast optics) introduced by Xin (2015) is used. If "offAxis",
        an empirical compensation polynomial is used. This is suitable for
        fast telescopes, far from the optical axis.
    instConfig : Path or str or dict or Instrument, optional
        Instrument configuration. If a Path or string, it is assumed this
        points to a config file, which is used to configure the Instrument.
        If a dictionary, it is assumed to hold keywords for configuration.
        If an Instrument object, that object is just used.
    """

    def __init__(
        self,
        configFile: Union[Path, str, None] = "policy/utils/imageMapper.yaml",
        opticalModel: Optional[str] = None,
        instConfig: Union[Path, str, dict, Instrument, None] = None,
    ) -> None:
        self.config(
            configFile=configFile,
            opticalModel=opticalModel,
            instConfig=instConfig,
        )

    def config(
        self,
        configFile: Union[Path, str, None] = None,
        opticalModel: Optional[str] = None,
        instConfig: Union[Path, str, dict, Instrument, None] = None,
    ) -> None:
        """Configure the image mapper.

        For details on the parameters, see the class docstring.
        """
        params = mergeParams(
            configFile,
            opticalModel=opticalModel,
            instConfig=instConfig,
        )

        # Set the optical model
        opticalModel = params["opticalModel"]
        if opticalModel is not None:
            allowed_opticalModels = ["paraxial", "onAxis", "offAxis"]
            if opticalModel not in allowed_opticalModels:
                raise ValueError(
                    f"optical model '{opticalModel}' not supported. "
                    f"Please choose one of {str(allowed_opticalModels)[1:-1]}."
                )
            self._opticalModel = opticalModel

        # Set the instrument
        instConfig = params["instConfig"]
        if instConfig is not None:
            self._instrument = loadConfig(instConfig, Instrument)

    @property
    def opticalModel(self) -> str:
        """Return the optical model.

        For details about this parameter, see the class docstring.
        """
        return self._opticalModel

    @property
    def instrument(self) -> Instrument:
        """Return the instrument object.

        For details about this parameter, see the class docstring.
        """
        return self._instrument

    def _addIntrinsicZernikes(
        self, fieldAngle: np.ndarray, zkCoeff: np.ndarray
    ) -> np.ndarray:
        """Add the intrinsic Zernikes to the input Zernikes coefficients.

        Note that the intrinsic Zernikes are just the OPD from the reference
        sphere. The wavefront associated with the reference sphere is
        incorporated in the mapping equations.

        Parameters
        ----------
        fieldAngle : np.ndarray
            The x- and y- field angle of the source to be mapped, in degrees.
        zkCoeff : np.ndarray
            The input Zernike coefficients, in meters

        Returns
        -------
        np.ndarray
            Zernikes coefficients (in meters) with the intrinsic
            aberrations incorporated
        """
        # In paraxial mode, we assume the intrinsic Zernikes are zero
        if self.opticalModel == "paraxial":
            return zkCoeff

        # In the off axis model, we need to load from parameter files
        # for now this is being generated by batoid
        # TODO: load from parameter file

        import batoid
        import galsim

        band = "r"
        telescope = batoid.Optic.fromYaml(f"LSST_{band}.yaml")
        bandpass = galsim.Bandpass(f"LSST_{band}.dat", wave_type="nm")

        # TODO: add field dependence here
        zkIntrinsic = (
            batoid.zernikeTA(
                telescope,
                *np.deg2rad(fieldAngle),
                bandpass.effective_wavelength * 1e-9,
                jmax=28,
                eps=telescope.pupilObscuration,
            )
            * bandpass.effective_wavelength
            * 1e-9
        )[4:]

        # Make sure the two Zernike arrays are the same length and add them
        size = max(zkCoeff.size, zkIntrinsic.size)

        zkTemp = np.zeros(size)
        zkTemp[: zkCoeff.size] = zkCoeff

        zkIntrinsicTemp = np.zeros(size)
        zkIntrinsicTemp[: zkIntrinsic.size] = zkIntrinsic

        return zkTemp + zkIntrinsicTemp

    def _constructMap(
        self,
        donutStamp: DonutStamp,
        zkCoeff: np.ndarray,
    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        """Construct the mapping between the image and pupil planes.

        Parameters
        ----------
        donutStamp : DonutStamp
            A stamp object containing the array to be mapped between the
            pupil and the image plane, plus the required metadata.
        zkCoeff : np.ndarray
            The wavefront at the pupil, represented as Zernike coefficients
            in meters for Noll indices >= 4.

        Returns
        -------
        np.ndarray
            Normalized x coordinates of the pupil grid
        np.ndarray
            Normalized y coordinates of the pupil grid
        np.ndarray
            Normalized x coordinates on the image plane
        np.ndarray
            Normalized y coordinates on the image plane
        np.ndarray
            The determinant of the Jacobian of the mapping
        """
        # Add the intrinsic Zernikes to the input zernikes
        zkMap = self._addIntrinsicZernikes(donutStamp.fieldAngle, zkCoeff)

        # Get instrument geometry info
        f = self.instrument.focalLength
        R = self.instrument.radius
        obscuration = self.instrument.obscuration
        l = self.instrument.defocalOffset  # noqa: E741

        # Determine defocal sign from the image plane at z = f +/- l
        # I.e., the extrafocal image at z = f + l is associated with +1,
        # and the intrafocal image at z = f - l is associated with -1.
        defocalSign = +1 if donutStamp.defocalType == DefocalType.Extra else -1

        # Get a regular (normalized) grid on the pupil
        nPixels = donutStamp.image.shape[0]
        uPupil, vPupil = self.instrument.createPupilGrid(nPixels)

        # Calculate all 1st- and 2nd-order Zernike derivatives
        d1Wdu = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=1,
            vOrder=0,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d1Wdv = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=0,
            vOrder=1,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d2Wdudu = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=2,
            vOrder=0,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d2Wdvdv = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=0,
            vOrder=2,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d2Wdudv = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=1,
            vOrder=1,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d2Wdvdu = d2Wdudv

        # Plus the first order derivatives at the center of the pupil
        d1Wdu0 = zernikeGradEval(
            np.zeros(1),
            np.zeros(1),
            uOrder=1,
            vOrder=0,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d1Wdv0 = zernikeGradEval(
            np.zeros(1),
            np.zeros(1),
            uOrder=0,
            vOrder=1,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )

        # Calculate A, B, and every permutation of C
        A = uPupil**2 + vPupil**2 + (f / R) ** 2
        B = (f + defocalSign * l) / (l * R) * np.sqrt(A)
        Cuu = uPupil / A * d1Wdu + d2Wdudu
        Cuv = uPupil / A * d1Wdv + d2Wdudv
        Cvu = vPupil / A * d1Wdu + d2Wdvdu
        Cvv = vPupil / A * d1Wdv + d2Wdvdv

        # Map the pupil grid to the image grid
        uImage = -defocalSign * uPupil - B * d1Wdu
        vImage = -defocalSign * vPupil - B * d1Wdv

        # Center the image of the pupil
        centerShiftScale = -f * (f + defocalSign * l) / (l * R**2)
        uImage -= centerShiftScale * d1Wdu0
        vImage -= centerShiftScale * d1Wdv0

        # And the determinant of the Jacobian
        detJac = (
            1
            + (defocalSign * B) * (Cuu + Cvv)
            + (defocalSign * B) ** 2 * (Cuu * Cvv - Cuv * Cvu)
        )

        return uPupil, vPupil, uImage, vImage, detJac

    def pupilToImage(
        self,
        donutStamp: DonutStamp,
        zkCoeff: np.ndarray = np.zeros(1),
    ) -> DonutStamp:
        """Map a stamp from the pupil to the image plane.

        Parameters
        ----------
        donutStamp : DonutStamp
            A stamp object containing the array to be mapped from the pupil
            to the image plane, plus the required metadata.
        zkCoeff : np.ndarray, optional
            The wavefront at the pupil, represented as Zernike coefficients
            in meters, for Noll indices >= 4. Note this is in addition to
            the intrinsic wavefront aberration.
            (the default is zero)

        Returns
        -------
        DonutStamp
            The stamp object mapped to the image plane.
        """
        # Make a copy of the stamp
        stamp = donutStamp.copy()

        # Construct the map between the pupil and image planes
        uPupil, vPupil, uImage, vImage, detJac = self._constructMap(
            stamp, zkCoeff,
        )

        # Mask the pupil. We do this in two steps so that it plays nicely
        # with the interpolation scheme below

        # First, we want an inner mask that we will use to set the intensity
        # inside the obscuration to zero. We will still project these points
        # onto the image plane so that the interpolator knows the interior 
        # of the obscuration has zero flux
        rPupil = np.sqrt(uPupil**2 + vPupil**2)
        innerMask = rPupil > self.instrument.obscuration
        
        # Second, we want an outer mask to totally ignore the points outside
        # a normalized pupil radius of 1. These points are supposed to have
        # zero flux too, but sometimes get mapped into the same areas as the
        # points with non-zero flux. The presence of these zero-flux points
        # in the same region of the pupil plane causes the interpolator to
        # decrease the flux in these areas, which it should not do
        outerMask = rPupil < 1

        # Interpolate onto the image plane
        image = griddata(
            (uImage[outerMask].ravel(), vImage[outerMask].ravel()),
            (innerMask * stamp.image / detJac)[outerMask].ravel(),
            (uPupil.ravel(), vPupil.ravel()),
            method="linear",
        ).reshape(uPupil.shape)

        # Set NaNs to zero
        image = np.nan_to_num(image)

        # Update the stamp with the new image
        stamp.config(image=image)

        return stamp

    def imageToPupil(
        self,
        donutStamp: DonutStamp,
        zkCoeff: np.ndarray = np.zeros(1),
    ) -> DonutStamp:
        """Map a stamp from the image to the pupil plane.

        Parameters
        ----------
        donutStamp : DonutStamp
            A stamp object containing the array to be mapped from the image
            to the pupil plane, plus the required metadata.
        zkCoeff : np.ndarray, optional
            The wavefront at the pupil, represented as Zernike coefficients
            in meters, for Noll indices >= 4. Note this is in addition to
            the intrinsic wavefront aberration.
            (the default is zero)

        Returns
        -------
        DonutStamp
            The stamp object mapped to the image plane.
        """
        # Make a copy of the stamp
        stamp = donutStamp.copy()

        # Get the map between the pupil and image planes
        uPupil, vPupil, uImage, vImage, detJac = self._constructMap(
            stamp, zkCoeff
        )

        # Interpolate the array onto the pupil plane
        pupil = interpn(
            (vPupil[:, 0], uPupil[0, :]),
            stamp.image,
            (vImage, uImage),
            method="linear",
            bounds_error=False,
        )
        pupil *= detJac

        # Set NaNs to zero
        pupil = np.nan_to_num(pupil)

        # Mask the pupil
        mask = self.instrument.createPupilMask(pupil.shape[0])
        pupil *= mask

        # Update the stamp with the new pupil image
        stamp.config(image=pupil)

        return stamp
