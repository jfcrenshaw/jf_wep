"""Class that maps the pupil to the image plane, and vice versa.

This is used in the TIE and Danish algorithms.
"""
from pathlib import Path
from typing import Optional, Tuple, Union

import numpy as np
from scipy.interpolate import griddata, interpn

from jf_wep.instrument import Instrument
from jf_wep.utils import DefocalType, loadConfig, mergeParams, zernikeGradEval


class ImageMapper:
    """Class for mapping the pupil to the image plane, and vice versa.

    Parameters
    ----------
    configFile : Path or str, optional
        Path to file specifying values for the other parameters. If the
        path starts with "policy/", it will look in the policy directory.
        Any explicitly passed parameters override values found in this file
        (the default is policy/utils/imageMapper.yaml)
    opticalModel : str, optional
        The optical model used for image compensation. If "paraxial", the
        original algorithm from Rodier & Rodier (1993) is used, which is
        suitable for images near the optical axis on telescope with large
        focal ratios. If "onAxis", the modification for small focal ratios
        (i.e. fast optics) introduced by Xin (2015) is used. If "offAxis",
        an empirical compensation polynomial is used. This is suitable for
        fast telescopes, far from the optical axis.
    instConfig : Path or str or dict or Instrument, optional
        Instrument configuration. If a Path or string, it is assumed this
        points to a config file, which is used to configure the Instrument.
        If a dictionary, it is assumed to hold keywords for configuration.
        If an Instrument object, that object is just used.
    """

    def __init__(
        self,
        configFile: Union[Path, str, None] = "policy/utils/imageMapper.yaml",
        opticalModel: Optional[str] = None,
        instConfig: Union[Path, str, dict, Instrument, None] = None,
    ) -> None:
        self.config(
            configFile=configFile,
            opticalModel=opticalModel,
            instConfig=instConfig,
        )

    def config(
        self,
        configFile: Union[Path, str, None] = None,
        opticalModel: Optional[str] = None,
        instConfig: Union[Path, str, dict, Instrument, None] = None,
    ) -> None:
        """Configure the image mapper.

        For details on the parameters, see the class docstring.
        """
        params = mergeParams(
            configFile,
            opticalModel=opticalModel,
            instConfig=instConfig,
        )

        # Set the optical model
        opticalModel = params["opticalModel"]
        if opticalModel is not None:
            allowed_opticalModels = ["paraxial", "onAxis", "offAxis"]
            if opticalModel not in allowed_opticalModels:
                raise ValueError(
                    f"optical model '{opticalModel}' not supported. "
                    f"Please choose one of {str(allowed_opticalModels)[1:-1]}."
                )
            self._opticalModel = opticalModel

        # Set the instrument
        instConfig = params["instConfig"]
        if instConfig is not None:
            self._instrument = loadConfig(instConfig, Instrument)

    @property
    def opticalModel(self) -> str:
        """Return the optical model.

        For details about this parameter, see the class docstring.
        """
        return self._opticalModel

    @property
    def instrument(self) -> Instrument:
        """Return the instrument object.

        For details about this parameter, see the class docstring.
        """
        return self._instrument

    def _addIntrinsicZernikes(self, zkCoeff: np.ndarray) -> np.ndarray:
        """Add the intrinsic Zernikes to the input Zernikes coefficients.

        Note that the intrinsic Zernikes are just the OPD from the reference
        sphere. The wavefront associated with the reference sphere is
        incorporated in the mapping equations.

        Parameters
        ----------
        zkCoeff: np.ndarray
            The input Zernike coefficients, in meters

        Returns
        -------
        np.ndarray
            Zernikes coefficients (in meters) with the intrinsic
            aberrations incorporated
        """
        # In paraxial mode, we assume the intrinsic Zernikes are zero
        if self.opticalModel == "paraxial":
            return zkCoeff

        # In the off axis model, we need to load from parameter files
        # for now this is being generated by batoid
        # TODO: load from parameter file

        import batoid
        import galsim

        band = "r"
        telescope = batoid.Optic.fromYaml(f"LSST_{band}.yaml")
        bandpass = galsim.Bandpass(f"LSST_{band}.dat", wave_type="nm")

        # TODO: add field dependence here
        zkIntrinsic = (
            batoid.zernikeTA(
                telescope,
                0,
                0,
                bandpass.effective_wavelength * 1e-9,
                jmax=28,
                eps=telescope.pupilObscuration,
            )
            * bandpass.effective_wavelength
            * 1e-9
        )[4:]

        # Make sure the two Zernike arrays are the same length and add them
        size = max(zkCoeff.size, zkIntrinsic.size)

        zkTemp = np.zeros(size)
        zkTemp[: zkCoeff.size] = zkCoeff

        zkIntrinsicTemp = np.zeros(size)
        zkIntrinsicTemp[: zkIntrinsic.size] = zkIntrinsic

        return zkTemp + zkIntrinsicTemp

    def _constructMap(
        self,
        nPixels: int,
        defocalType: DefocalType,
        zkCoeff: np.ndarray,
    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        """Construct the mapping between the image and pupil planes.

        Parameters
        ----------
        nPixels : int
            The number of pixels on a side for the pixelization of the pupil.
        defocalType : DefocalType
            A DefocalType enum that specifies whether the image plane is the
            intrafocal or extrafocal image plane.
        zkCoeff : np.ndarray
            The wavefront at the pupil, represented as Zernike coefficients
            in meters for Noll indices >= 4.

        Returns
        -------
        np.ndarray
            Normalized x coordinates of the pupil grid
        np.ndarray
            Normalized y coordinates of the pupil grid
        np.ndarray
            Normalized x coordinates on the image plane
        np.ndarray
            Normalized y coordinates on the image plane
        np.ndarray
            The determinant of the Jacobian of the mapping
        """
        # Add the intrinsic Zernikes to the input zernikes
        zkMap = self._addIntrinsicZernikes(zkCoeff)

        # Get instrument geometry info
        f = self.instrument.focalLength
        R = self.instrument.radius
        obscuration = self.instrument.obscuration
        l = self.instrument.defocalOffset  # noqa: E741

        # Determine defocal sign from the image plane at z = f +/- l
        # I.e., the extrafocal image at z = f + l is associated with +1,
        # and the intrafocal image at z = f - l is associated with -1.
        defocalSign = +1 if defocalType == DefocalType.Extra else -1

        # Get a regular (normalized) grid on the pupil
        uPupil, vPupil = self.instrument.createPupilGrid(nPixels)

        # Calculate all 1st- and 2nd-order Zernike derivatives
        d1Wdu = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=1,
            vOrder=0,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d1Wdv = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=0,
            vOrder=1,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d2Wdudu = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=2,
            vOrder=0,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d2Wdvdv = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=0,
            vOrder=2,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d2Wdudv = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=1,
            vOrder=1,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d2Wdvdu = d2Wdudv

        # Plus the first order derivatives at the center of the pupil
        d1WduCenter = zernikeGradEval(
            np.zeros(1),
            np.zeros(1),
            uOrder=1,
            vOrder=0,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d1WdvCenter = zernikeGradEval(
            np.zeros(1),
            np.zeros(1),
            uOrder=0,
            vOrder=1,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )

        # Calculate A, B, and every permutation of C
        A = uPupil**2 + vPupil**2 + (f / R) ** 2
        B = (f + defocalSign * l) / (l * R) * np.sqrt(A)
        Cuu = uPupil / A * d1Wdu + d2Wdudu
        Cuv = uPupil / A * d1Wdv + d2Wdudv
        Cvu = vPupil / A * d1Wdu + d2Wdvdu
        Cvv = vPupil / A * d1Wdv + d2Wdvdv

        # Map the pupil grid to the image grid
        uImage = -defocalSign * uPupil - B * d1Wdu
        vImage = -defocalSign * vPupil - B * d1Wdv

        # Center the image of the pupil
        centerShiftScale = -f * (f + defocalSign * l) / (l * R**2)
        uImage -= centerShiftScale * d1WduCenter
        vImage -= centerShiftScale * d1WdvCenter

        # And the determinant of the Jacobian
        detJac = (
            1
            + (defocalSign * B) * (Cuu + Cvv)
            + (defocalSign * B) ** 2 * (Cuu * Cvv - Cuv * Cvu)
        )

        return uPupil, vPupil, uImage, vImage, detJac

    def pupilToImage(
        self,
        array: np.ndarray,
        defocalType: DefocalType,
        zkCoeff: np.ndarray = np.zeros(1),
    ) -> np.ndarray:
        """Map an array from the pupil to the image plane.

        Parameters
        ----------
        array : np.ndarray
            The array to be mapped from the pupil to the image plane.
        defocalType : DefocalType
            A DefocalType enum that specifies whether to map to the intrafocal
            or extrafocal image plane.
        zkCoeff : np.ndarray, optional
            The wavefront at the pupil, represented as Zernike coefficients
            in nm for Noll indices >= 4. Note this is in addition to the
            intrinsic wavefront aberration.
            (the default is zero)

        Returns
        -------
        np.ndarray
            The array mapped to the image plane.
        """
        # Construct the map between the pupil and image planes
        uPupil, vPupil, uImage, vImage, detJac = self._constructMap(
            array.shape[0], defocalType, zkCoeff
        )

        # Interpolate the array onto the image plane
        image = griddata(
            (uImage.ravel(), vImage.ravel()),
            (array / detJac).ravel(),
            (uPupil.ravel(), vPupil.ravel()),
            method="linear",
        ).reshape(uPupil.shape)

        # Replace NaNs with zeros
        image = np.nan_to_num(image)

        return image

    def imageToPupil(
        self,
        array: np.ndarray,
        defocalType: DefocalType,
        zkCoeff: np.ndarray = np.zeros(1),
    ) -> np.ndarray:
        """Map an array from the image to the pupil plane.

        Parameters
        ----------
        array : np.ndarray
            The array to be mapped from the image to the pupil plane.
        defocalType : DefocalType
            A DefocalType enum that specifies whether to map from the
            intrafocal or extrafocal image plane.
        zkCoeff : np.ndarray, optional
            The wavefront at the pupil, represented as Zernike coefficients
            in nm for Noll indices >= 4. Note this is in addition to the
            intrinsic wavefront aberration.
            (the default is zero)

        Returns
        -------
        np.ndarray
            The array mapped to the pupil plane.
        """
        # Get the map between the pupil and image planes
        uPupil, vPupil, uImage, vImage, detJac = self._constructMap(
            array.shape[0], defocalType, zkCoeff
        )

        # Interpolate the array onto the pupil plane
        pupil = interpn(
            (vPupil[:, 0], uPupil[0, :]),
            array,
            (vImage, uImage),
            method="linear",
            bounds_error=False,
        )
        pupil *= detJac

        # Replace NaNs with zeros
        pupil = np.nan_to_num(pupil)

        return pupil
