"""Class that maps the pupil to the image plane, and vice versa.

This is used in the TIE and Danish algorithms.
"""
from pathlib import Path
from typing import Optional, Tuple, Union

import numpy as np
from scipy.interpolate import griddata, interpn
from scipy.spatial import ConvexHull, Delaunay

from jf_wep.donutStamp import DonutStamp
from jf_wep.instrument import Instrument
from jf_wep.utils import DefocalType, loadConfig, mergeParams, zernikeGradEval


class ImageMapper:
    """Class for mapping the pupil to the image plane, and vice versa.

    Parameters
    ----------
    configFile : Path or str, optional
        Path to file specifying values for the other parameters. If the
        path starts with "policy/", it will look in the policy directory.
        Any explicitly passed parameters override values found in this file
        (the default is policy/utils/imageMapper.yaml)
    instConfig : Path or str or dict or Instrument, optional
        Instrument configuration. If a Path or string, it is assumed this
        points to a config file, which is used to configure the Instrument.
        If a dictionary, it is assumed to hold keywords for configuration.
        If an Instrument object, that object is just used.
    addIntrinsic : bool, optional
        Whether to explicitly add the intrinsic Zernike coefficients to
        the Zernike coefficients provided for image mapping.
    """

    def __init__(
        self,
        configFile: Union[Path, str, None] = "policy/utils/imageMapper.yaml",
        instConfig: Union[Path, str, dict, Instrument, None] = None,
        addIntrinsic: Optional[bool] = None,
    ) -> None:
        # Merge keyword arguments with defaults from configFile
        params = mergeParams(
            configFile,
            instConfig=instConfig,
            addIntrinsic=addIntrinsic,
        )

        # Configure the instrument
        self.configInstrument(params["instConfig"])

        # Set the addIntrinsic flag
        self.addIntrinsic = params["addIntrinsic"]

    def configInstrument(
        self, instConfig: Union[Instrument, Path, str, dict]
    ) -> None:
        """Configure the instrument.

        For details about this parameter, see the class docstring.
        """
        self._instrument = loadConfig(instConfig, Instrument)

    @property
    def instrument(self) -> Instrument:
        """Return the instrument object.

        For details about this parameter, see the class docstring.
        """
        return self._instrument

    @property
    def addIntrinsic(self) -> bool:
        """Flag indicating whether intrinsic Zernikes are explicitly added.

        For details about this parameter, see the class docstring.
        """
        return self._addIntrinsic

    @addIntrinsic.setter
    def addIntrinsic(self, value: bool) -> None:
        if not isinstance(value, bool):
            raise TypeError("addIntrinic must be a bool.")
        self._addIntrinsic = value

    def _addIntrinsicZernikes(
        self, fieldAngle: np.ndarray, zkCoeff: np.ndarray
    ) -> np.ndarray:
        """Add the intrinsic Zernikes to the input Zernikes coefficients.

        Note that the intrinsic Zernikes are just the OPD from the reference
        sphere. The wavefront associated with the reference sphere is
        incorporated in the mapping equations.

        Parameters
        ----------
        fieldAngle : np.ndarray
            The x- and y- field angle of the source to be mapped, in degrees.
        zkCoeff : np.ndarray
            The input Zernike coefficients, in meters

        Returns
        -------
        np.ndarray
            Zernikes coefficients (in meters) with the intrinsic
            aberrations incorporated
        """
        # In paraxial mode, we assume the intrinsic Zernikes are zero
        if not self.addIntrinsic:
            return zkCoeff

        # In the off axis model, we need to load from parameter files
        # for now this is being generated by batoid
        # TODO: load from parameter file

        import batoid
        import galsim

        band = "r"
        telescope = batoid.Optic.fromYaml(f"LSST_{band}.yaml")
        bandpass = galsim.Bandpass(f"LSST_{band}.dat", wave_type="nm")
        wavelength = bandpass.effective_wavelength * 1e-9

        # TODO: add field dependence here
        zkIntrinsic = (
            batoid.zernike(
                telescope,
                *np.deg2rad(fieldAngle),
                wavelength,
                jmax=66,
                eps=telescope.pupilObscuration,
            )
            * wavelength
        )[4:]

        # Make sure the two Zernike arrays are the same length and add them
        size = max(zkCoeff.size, zkIntrinsic.size)

        zkTemp = np.zeros(size)
        zkTemp[: zkCoeff.size] = zkCoeff

        zkIntrinsicTemp = np.zeros(size)
        zkIntrinsicTemp[: zkIntrinsic.size] = zkIntrinsic

        return zkTemp + zkIntrinsicTemp

    def _constructMap(
        self,
        donutStamp: DonutStamp,
        zkCoeff: np.ndarray,
    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        """Construct the mapping between the image and pupil planes.

        Parameters
        ----------
        donutStamp : DonutStamp
            A stamp object containing the array to be mapped between the
            pupil and the image plane, plus the required metadata.
        zkCoeff : np.ndarray
            The wavefront at the pupil, represented as Zernike coefficients
            in meters for Noll indices >= 4.

        Returns
        -------
        np.ndarray
            Normalized x coordinates of the pupil grid
        np.ndarray
            Normalized y coordinates of the pupil grid
        np.ndarray
            Normalized x coordinates on the image plane
        np.ndarray
            Normalized y coordinates on the image plane
        np.ndarray
            The determinant of the Jacobian of the mapping
        """
        # Add the intrinsic Zernikes to the input zernikes
        zkMap = self._addIntrinsicZernikes(donutStamp.fieldAngle, zkCoeff)

        # Get instrument geometry info
        N = self.instrument.focalRatio
        l = self.instrument.defocalOffset  # noqa: E741
        obscuration = self.instrument.obscuration

        # Determine defocal sign from the image plane at z = f +/- l
        # I.e., the extrafocal image at z = f + l is associated with +1,
        # and the intrafocal image at z = f - l is associated with -1.
        defocalSign = +1 if donutStamp.defocalType == DefocalType.Extra else -1

        # Get a regular (normalized) grid on the pupil
        nPixels = donutStamp.image.shape[0]
        uPupil, vPupil = self.instrument.createPupilGrid(nPixels)
        rPupil = np.sqrt(uPupil**2 + vPupil**2)

        # Calculate all 1st- and 2nd-order Zernike derivatives
        d1Wdu = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=1,
            vOrder=0,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d1Wdv = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=0,
            vOrder=1,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d2Wdudu = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=2,
            vOrder=0,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d2Wdvdv = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=0,
            vOrder=2,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d2Wdudv = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=1,
            vOrder=1,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d2Wdvdu = d2Wdudv

        # Plus the first order derivatives at the center of the pupil
        d1Wdu0 = zernikeGradEval(
            np.zeros(1),
            np.zeros(1),
            uOrder=1,
            vOrder=0,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d1Wdv0 = zernikeGradEval(
            np.zeros(1),
            np.zeros(1),
            uOrder=0,
            vOrder=1,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )

        # Map the pupil grid onto the image plane
        with np.errstate(invalid="ignore"):
            prefactor = np.sqrt((4 * N**2 - 1) / (4 * N**2 - rPupil**2))
        uImage = prefactor * (-defocalSign * uPupil - 4 * N**2 / l * d1Wdu)
        vImage = prefactor * (-defocalSign * vPupil - 4 * N**2 / l * d1Wdv)

        # Center the image of the pupil
        uImage += np.sqrt(4 * N**2 - 1) * 2 * N / l * d1Wdu0
        vImage += np.sqrt(4 * N**2 - 1) * 2 * N / l * d1Wdv0

        # Calculate the Jacobian
        J00 = uPupil * uImage / (4 * N**2 - rPupil**2) - prefactor * (
            defocalSign + 4 * N**2 / l * d2Wdudu
        )
        J01 = (
            vPupil * uImage / (4 * N**2 - rPupil**2)
            - prefactor * 4 * N**2 / l * d2Wdvdu
        )
        J10 = (
            uPupil * vImage / (4 * N**2 - rPupil**2)
            - prefactor * 4 * N**2 / l * d2Wdudv
        )
        J11 = vPupil * vImage / (4 * N**2 - rPupil**2) - prefactor * (
            defocalSign + 4 * N**2 / l * d2Wdvdv
        )

        # And the determinant
        detJac = J00 * J11 - J01 * J10

        return uPupil, vPupil, uImage, vImage, detJac

    def _createImageMask(
        self,
        uPupil: np.ndarray,
        vPupil: np.ndarray,
        uImage: np.ndarray,
        vImage: np.ndarray,
    ) -> np.ndarray:
        """Map the pupil mask to the image plane.

        This is the private version of self.createImageMask() that
        assumes you have already created the mapping between the
        pupil and image planes.

        Parameters
        ----------
        np.ndarray
            Normalized x coordinates of the pupil grid
        np.ndarray
            Normalized y coordinates of the pupil grid
        np.ndarray
            Normalized x coordinates on the image plane
        np.ndarray
            Normalized y coordinates on the image plane

        Returns
        -------
        np.ndarray
            The mask array.
        """
        # Unravel the grid points to be used below
        gridPoints = np.transpose((uPupil.ravel(), vPupil.ravel()))

        # Create inner and outer masks
        rPupil = np.sqrt(uPupil**2 + vPupil**2)
        innerMask = rPupil <= self.instrument.obscuration
        outerMask = rPupil <= 1

        # Find the convex hull of the inner mask mapped to the image plane,
        # and use that as the inner image mask
        innerMaskPts = np.transpose(
            (uImage[innerMask].ravel(), vImage[innerMask].ravel())
        )
        innerHull = ConvexHull(innerMaskPts)
        innerDeln = Delaunay(innerMaskPts[innerHull.vertices])
        innerMask = (
            innerDeln.find_simplex(gridPoints).reshape(uPupil.shape) >= 0
        )

        # Find the convex hull of the outer mask mapped to the image plane,
        # and use that as the outer image mask
        outerMaskPts = np.transpose(
            (uImage[outerMask].ravel(), vImage[outerMask].ravel())
        )
        outerHull = ConvexHull(outerMaskPts)
        outerDeln = Delaunay(outerMaskPts[outerHull.vertices])
        outerMask = (
            outerDeln.find_simplex(gridPoints).reshape(uPupil.shape) >= 0
        )

        # Combine the masks
        imageMask = outerMask & ~innerMask

        return imageMask

    def createImageMask(
        self,
        donutStamp: DonutStamp,
        zkCoeff: np.ndarray = np.zeros(1),
    ) -> np.ndarray:
        """Create an image mask for the donut stamp.

        Parameters
        ----------
        donutStamp : DonutStamp
            The stamp object for which the image mask is created.
        zkCoeff : np.ndarray, optional
            The wavefront at the pupil, represented as Zernike coefficients
            in meters, for Noll indices >= 4. Note this is in addition to
            the intrinsic wavefront aberration.
            (the default is zero)

        Returns
        -------
        np.ndarray
            The mask array.
        """
        # Construct the map between the pupil and image planes
        uPupil, vPupil, uImage, vImage, detJac = self._constructMap(
            donutStamp,
            zkCoeff,
        )

        return self._createImageMask(uPupil, vPupil, uImage, vImage)

    def pupilToImage(
        self,
        donutStamp: DonutStamp,
        zkCoeff: np.ndarray = np.zeros(1),
    ) -> DonutStamp:
        """Map a stamp from the pupil to the image plane.

        Parameters
        ----------
        donutStamp : DonutStamp
            A stamp object containing the array to be mapped from the pupil
            to the image plane, plus the required metadata.
        zkCoeff : np.ndarray, optional
            The wavefront at the pupil, represented as Zernike coefficients
            in meters, for Noll indices >= 4. Note this is in addition to
            the intrinsic wavefront aberration.
            (the default is zero)

        Returns
        -------
        DonutStamp
            The stamp object mapped to the image plane.
        """
        # Make a copy of the stamp
        stamp = donutStamp.copy()

        # Construct the map between the pupil and image planes
        uPupil, vPupil, uImage, vImage, detJac = self._constructMap(
            stamp,
            zkCoeff,
        )

        # Create the pupil and image masks
        # Mask the pupil
        pupilMask = self.instrument.createPupilMask(stamp.image.shape[0])
        imageMask = self._createImageMask(uPupil, vPupil, uImage, vImage)

        # Use nearest neighbors to interpolate projected image points
        # onto a regular grid
        image = np.zeros_like(uPupil)
        image[imageMask] = griddata(
            (uImage[pupilMask].ravel(), vImage[pupilMask].ravel()),
            (stamp.image / detJac)[pupilMask].ravel(),
            (uPupil[imageMask], vPupil[imageMask]),
            method="nearest",
        )

        # Update the stamp with the new image
        stamp.image = image

        return stamp

    def imageToPupil(
        self,
        donutStamp: DonutStamp,
        zkCoeff: np.ndarray = np.zeros(1),
    ) -> DonutStamp:
        """Map a stamp from the image to the pupil plane.

        Parameters
        ----------
        donutStamp : DonutStamp
            A stamp object containing the array to be mapped from the image
            to the pupil plane, plus the required metadata.
        zkCoeff : np.ndarray, optional
            The wavefront at the pupil, represented as Zernike coefficients
            in meters, for Noll indices >= 4. Note this is in addition to
            the intrinsic wavefront aberration.
            (the default is zero)

        Returns
        -------
        DonutStamp
            The stamp object mapped to the image plane.
        """
        # Make a copy of the stamp
        stamp = donutStamp.copy()

        # Get the map between the pupil and image planes
        uPupil, vPupil, uImage, vImage, detJac = self._constructMap(
            stamp, zkCoeff
        )

        # Interpolate the array onto the pupil plane
        pupil = interpn(
            (vPupil[:, 0], uPupil[0, :]),
            stamp.image,
            (vImage, uImage),
            method="linear",
            bounds_error=False,
        )
        pupil *= detJac

        # Set NaNs to zero
        pupil = np.nan_to_num(pupil)

        # Mask the pupil
        mask = self.instrument.createPupilMask(pupil.shape[0])
        pupil *= mask

        # Update the stamp with the new pupil image
        stamp.image = pupil

        return stamp
