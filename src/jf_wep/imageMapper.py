"""Class that maps the pupil to the image plane, and vice versa.

This is used in the TIE and Danish algorithms.
"""
from pathlib import Path
from typing import Optional, Tuple, Union

import galsim
import numpy as np
from scipy.interpolate import interpn

from jf_wep.donutStamp import DonutStamp
from jf_wep.instrument import Instrument
from jf_wep.utils import (
    DefocalType,
    loadConfig,
    mergeParams,
    zernikeGradEval,
    polygonContains,
)


class ImageMapper:
    """Class for mapping the pupil to the image plane, and vice versa.

    Parameters
    ----------
    configFile : Path or str, optional
        Path to file specifying values for the other parameters. If the
        path starts with "policy/", it will look in the policy directory.
        Any explicitly passed parameters override values found in this file
        (the default is policy/utils/imageMapper.yaml)
    instConfig : Path or str or dict or Instrument, optional
        Instrument configuration. If a Path or string, it is assumed this
        points to a config file, which is used to configure the Instrument.
        If a dictionary, it is assumed to hold keywords for configuration.
        If an Instrument object, that object is just used.
    addIntrinsic : bool, optional
        Whether to explicitly add the intrinsic Zernike coefficients to
        the Zernike coefficients provided for image mapping.
    """

    def __init__(
        self,
        configFile: Union[Path, str, None] = "policy/imageMapper.yaml",
        instConfig: Union[Path, str, dict, Instrument, None] = None,
        addIntrinsic: Optional[bool] = None,
    ) -> None:
        # Merge keyword arguments with defaults from configFile
        params = mergeParams(
            configFile,
            instConfig=instConfig,
            addIntrinsic=addIntrinsic,
        )

        # Configure the instrument
        self.configInstrument(params["instConfig"])

        # Set the addIntrinsic flag
        self.addIntrinsic = params["addIntrinsic"]

    def configInstrument(
        self, instConfig: Union[Instrument, Path, str, dict]
    ) -> None:
        """Configure the instrument.

        For details about this parameter, see the class docstring.
        """
        self._instrument = loadConfig(instConfig, Instrument)

    @property
    def instrument(self) -> Instrument:
        """Return the instrument object.

        For details about this parameter, see the class docstring.
        """
        return self._instrument

    @property
    def addIntrinsic(self) -> bool:
        """Flag indicating whether intrinsic Zernikes are explicitly added.

        For details about this parameter, see the class docstring.
        """
        return self._addIntrinsic

    @addIntrinsic.setter
    def addIntrinsic(self, value: bool) -> None:
        if not isinstance(value, bool):
            raise TypeError("addIntrinic must be a bool.")
        self._addIntrinsic = value

    def _addIntrinsicZernikes(
        self, fieldAngle: np.ndarray, zkCoeff: np.ndarray
    ) -> np.ndarray:
        """Add the intrinsic Zernikes to the input Zernikes coefficients.

        Note that the intrinsic Zernikes are just the OPD from the reference
        sphere. The wavefront associated with the reference sphere is
        incorporated in the mapping equations.

        Parameters
        ----------
        fieldAngle : np.ndarray
            The x- and y- field angle of the source to be mapped, in degrees.
        zkCoeff : np.ndarray
            The input Zernike coefficients, in meters

        Returns
        -------
        np.ndarray
            Zernikes coefficients (in meters) with the intrinsic
            aberrations incorporated
        """
        # In paraxial mode, we assume the intrinsic Zernikes are zero
        if not self.addIntrinsic:
            return zkCoeff

        # In the off axis model, we need to load from parameter files
        # for now this is being generated by batoid
        # TODO: load from parameter file

        import batoid
        import galsim

        band = "r"
        telescope = batoid.Optic.fromYaml(f"LSST_{band}.yaml")
        bandpass = galsim.Bandpass(f"LSST_{band}.dat", wave_type="nm")
        wavelength = bandpass.effective_wavelength * 1e-9

        # TODO: add field dependence here
        zkIntrinsic = (
            batoid.zernike(
                telescope,
                *np.deg2rad(fieldAngle),
                wavelength,
                jmax=66,
                eps=telescope.pupilObscuration,
            )
            * wavelength
        )[4:]

        # Make sure the two Zernike arrays are the same length and add them
        size = max(zkCoeff.size, zkIntrinsic.size)

        zkTemp = np.zeros(size)
        zkTemp[: zkCoeff.size] = zkCoeff

        zkIntrinsicTemp = np.zeros(size)
        zkIntrinsicTemp[: zkIntrinsic.size] = zkIntrinsic

        return zkTemp + zkIntrinsicTemp

    def _constructForwardMap(
        self,
        uPupil: np.ndarray,
        vPupil: np.ndarray,
        zkCoeff: np.ndarray,
        donutStamp: DonutStamp,
    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        """Construct the forward mapping from the pupil to the image plane.

        Parameters
        ----------
        uPupil : np.ndarray
             Normalized x coordinates on the pupil plane
        vPupil : np.ndarray
             Normalized y coordinates on the image plane
        zkCoeff : np.ndarray
            The wavefront at the pupil, represented as Zernike coefficients
            in meters for Noll indices >= 4.
        donutStamp : DonutStamp
            A stamp object containing the metadata required for the mapping.

        Returns
        -------
        np.ndarray
            Normalized x coordinates on the image plane
        np.ndarray
            Normalized y coordinates on the image plane
        np.ndarray
            The Jacobian of the forward map
        np.ndarray
            The determinant of the Jacobian
        """
        # Add the intrinsic Zernikes to the input zernikes
        zkMap = self._addIntrinsicZernikes(donutStamp.fieldAngle, zkCoeff)

        # Get instrument geometry info
        N = self.instrument.focalRatio
        l = self.instrument.defocalOffset  # noqa: E741
        obscuration = self.instrument.obscuration

        # Determine defocal sign from the image plane at z = f +/- l
        # I.e., the extrafocal image at z = f + l is associated with +1,
        # and the intrafocal image at z = f - l is associated with -1.
        defocalSign = +1 if donutStamp.defocalType == DefocalType.Extra else -1

        # Calculate all 1st- and 2nd-order Zernike derivatives
        d1Wdu = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=1,
            vOrder=0,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d1Wdv = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=0,
            vOrder=1,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d2Wdudu = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=2,
            vOrder=0,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d2Wdvdv = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=0,
            vOrder=2,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d2Wdudv = zernikeGradEval(
            uPupil,
            vPupil,
            uOrder=1,
            vOrder=1,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d2Wdvdu = d2Wdudv

        # Plus the first order derivatives at the center of the pupil
        d1Wdu0 = zernikeGradEval(
            np.zeros(1),
            np.zeros(1),
            uOrder=1,
            vOrder=0,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )
        d1Wdv0 = zernikeGradEval(
            np.zeros(1),
            np.zeros(1),
            uOrder=0,
            vOrder=1,
            zkCoeff=zkMap,
            obscuration=obscuration,
        )

        # Map the pupil grid onto the image plane
        rPupil = np.sqrt(uPupil**2 + vPupil**2)

        with np.errstate(invalid="ignore"):
            prefactor = np.sqrt((4 * N**2 - 1) / (4 * N**2 - rPupil**2))
        uImage = prefactor * (
            -defocalSign * uPupil - 4 * N**2 / l * (d1Wdu - d1Wdu0)
        )
        vImage = prefactor * (
            -defocalSign * vPupil - 4 * N**2 / l * (d1Wdv - d1Wdv0)
        )

        # Calculate the Jacobian
        J00 = uPupil * uImage / (4 * N**2 - rPupil**2) - prefactor * (
            defocalSign + 4 * N**2 / l * d2Wdudu
        )
        J01 = (
            vPupil * uImage / (4 * N**2 - rPupil**2)
            - prefactor * 4 * N**2 / l * d2Wdvdu
        )
        J10 = (
            uPupil * vImage / (4 * N**2 - rPupil**2)
            - prefactor * 4 * N**2 / l * d2Wdudv
        )
        J11 = vPupil * vImage / (4 * N**2 - rPupil**2) - prefactor * (
            defocalSign + 4 * N**2 / l * d2Wdvdv
        )
        jac = np.array(
            [
                [J00, J01],
                [J10, J11],
            ]
        )

        """num = np.sqrt(4 * N**2 - 1)
        with np.errstate(invalid="ignore"):
            den = np.sqrt(4 * N**2 - rPupil**2)
        F = -defocalSign * num / den
        C = - 2 * N / l * num
        uImage = F * uPupil + C * (d1Wdu - d1Wdu0)
        vImage = F * vPupil + C * (d1Wdv - d1Wdv0)

        J00 = F * (1 + uPupil**2 / den**2) + C * d2Wdudu
        J01 = F * uPupil * vPupil / den**2 + C * d2Wdvdu
        J10 = F * vPupil * uPupil / den**2 + C * d2Wdudv
        J11 = F * (1 + vPupil**2 / den**2) + C * d2Wdvdv
        jac = np.array(
            [
                [J00, J01],
                [J10, J11],
            ]
        )"""
        
        # And the determinant
        jacDet = J00 * J11 - J01 * J10

        return uImage, vImage, jac, jacDet

    def _constructInverseMap(
        self,
        uImage: np.ndarray,
        vImage: np.ndarray,
        zkCoeff: np.ndarray,
        donutStamp: DonutStamp,
    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        """Construct the inverse mapping from the image plane to the pupil.

        Parameters
        ----------
        uImage : np.ndarray
            Normalized x coordinates on the image plane
        vImage : np.ndarray
            Normalized y coordinates on the image plane
        zkCoeff : np.ndarray
            The wavefront at the pupil, represented as Zernike coefficients
            in meters for Noll indices >= 4.
        donutStamp : DonutStamp
            A stamp object containing the metadata required for the mapping.

        Returns
        -------
        np.ndarray
            Normalized x coordinates on the pupil plane
        np.ndarray
            Normalized y coordinates on the pupil plane
        np.ndarray
            The Jacobian of the inverse mapping
        np.ndarray
            The determinant of the Jacobian
        """
        # Create a test grid on the pupil to pre-fit the image -> pupil mapping
        uPupilTest = np.linspace(-1, 1, 10)
        uPupilTest, vPupilTest = np.meshgrid(uPupilTest, uPupilTest)

        # Mask outside the pupil
        rPupilTest = np.sqrt(uPupilTest**2 + vPupilTest**2)
        pupilMask = rPupilTest <= 1
        pupilMask &= rPupilTest >= self.instrument.obscuration
        uPupilTest = uPupilTest[pupilMask]
        vPupilTest = vPupilTest[pupilMask]

        # Project the test pupil grid onto the image plane
        uImageTest, vImageTest, jac, jacDet = self._constructForwardMap(
            uPupilTest,
            vPupilTest,
            zkCoeff,
            donutStamp,
        )

        # Use test points to fit Zernike coefficients for image -> pupil mapping
        rImageMax = np.sqrt(uImageTest**2 + vImageTest**2).max()
        invCoeff, *_ = np.linalg.lstsq(
            galsim.zernike.zernikeBasis(
                6,
                uImageTest,
                vImageTest,
                R_outer=rImageMax,
            ).T,
            np.array([uPupilTest, vPupilTest]).T,
            rcond=None,
        )

        # Now we will map our image points to the pupil using the coefficients
        # we just fit, and then map them back to the image plane using the
        # analytic forward mapping
        # Ideally, this round-trip mapping will return the same image points
        # we started with, however our initial image -> pupil mapping will not
        # be perfect, so this will not be the case. We will iteratively apply
        # Newton's method to reduce the residuals, and thereby improve the
        # mapping

        # Map the image points to the pupil
        uPupil = galsim.zernike.Zernike(
            invCoeff[:, 0],
            R_outer=rImageMax,
        )(uImage, vImage)
        vPupil = galsim.zernike.Zernike(
            invCoeff[:, 1],
            R_outer=rImageMax,
        )(uImage, vImage)

        # Map these pupil points back to the image (RT = round-trip)
        uImageRT, vImageRT, jac, jacDet = self._constructForwardMap(
            uPupil,
            vPupil,
            zkCoeff,
            donutStamp,
        )

        # Calculate the residuals of the round-trip mapping
        duImage = uImageRT - uImage
        dvImage = vImageRT - vImage

        # Now iterate Newton's method to improve the mapping
        # (i.e. minimize the residuals)
        for i in range(10):
            # Add corrections to the pupil coordinates using Newton's method
            uPupil -= (+jac[1, 1] * duImage - jac[0, 1] * dvImage) / jacDet
            vPupil -= (-jac[1, 0] * duImage + jac[0, 0] * dvImage) / jacDet

            # Map these new pupil points to the image plane
            uImageRT, vImageRT, jac, jacDet = self._constructForwardMap(
                uPupil,
                vPupil,
                zkCoeff,
                donutStamp,
            )

            # Calculate the new residuals
            duImage = uImageRT - uImage
            dvImage = vImageRT - vImage

            # If the residuals are small enough, stop iterating
            maxResiduals = np.max([np.abs(duImage), np.abs(dvImage)], axis=0)
            if np.all(maxResiduals <= 1e-5):
                break

        # Set not-converged points to NaN
        notConverged = maxResiduals > 1e-5
        uPupil[notConverged] = np.nan
        vPupil[notConverged] = np.nan
        jac[..., notConverged] = np.nan
        jacDet[notConverged] = np.nan

        # Invert the Jacobian
        jac = (
            np.array([[jac[1, 1], -jac[0, 1]], [-jac[1, 0], jac[0, 0]]])
            / jacDet
        )
        jacDet = 1 / jacDet

        return uPupil, vPupil, jac, jacDet

    def _getImageGridInsidePupil(
        self,
        zkCoeff: np.ndarray,
        donutStamp: DonutStamp,
    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Return the image grid and a mask for which pixels are inside the pupil.

        Note a pixel is considered inside the pupil if any fraction of the pixel
        is inside the pupil. In addition, the pupil considered is the pupil
        mapped to the image plane.

        Parameters
        ----------
        zkCoeff : np.ndarray
            The wavefront at the pupil, represented as Zernike coefficients
            in meters for Noll indices >= 4.
        donutStamp : DonutStamp
            A stamp object containing the metadata required for the mapping.

        Returns
        -------
        np.ndarray
            Normalized x coordinates on the image plane
        np.ndarray
            Normalized y coordinates on the image plane
        np.ndarray
            Binary mask array indicating whether each pixel is inside the pupil
        """
        # Map pupil edge to the image to determine edge of pupil on the image
        theta = np.linspace(0, 2 * np.pi, 100)
        uPupil, vPupil = np.cos(theta), np.sin(theta)
        uImageEdge, vImageEdge, *_ = self._constructForwardMap(
            uPupil,
            vPupil,
            zkCoeff,
            donutStamp,
        )
        imageEdge = np.array([uImageEdge, vImageEdge]).T

        # Create an image grid
        nPixels = donutStamp.image.shape[0]
        uImage, vImage = self.instrument.createImageGrid(nPixels)

        # Determine which image pixels have corners inside the pupil
        dPixel = uImage[0, 1] - uImage[0, 0]
        corners = np.append(uImage[0] - dPixel / 2, uImage[0, -1] + dPixel / 2)
        cornersIn = polygonContains(*np.meshgrid(corners, corners), imageEdge)

        # Select pixels that have at least one corner inside
        inside = (
            cornersIn[:-1, :-1]
            | cornersIn[1:, :-1]
            | cornersIn[:-1, 1:]
            | cornersIn[1:, 1:]
        )

        return uImage, vImage, inside

    def _maskWithCircle(
        self,
        uPupil: np.ndarray,
        vPupil: np.ndarray,
        uPupilCirc: float,
        vPupilCirc: float,
        rPupilCirc: float,
        fwdMap: Optional[tuple] = None,
    ) -> np.ndarray:
        """Return a fractional mask for a single circle.

        Parameters
        ----------
        uPupil : np.ndarray
            Normalized x coordinates on the pupil plane
        vPupil : np.ndarray
            Normalized y coordinates on the pupil plane
        uPupilCirc : float
            The u coordinate of the circle center
        vPupilCirc : float
            The v coordinate of the circle center
        rPupilCirc : float
            The normalized radius of the circle
        fwdMap : tuple
            A tuple containing (uImage, vImage, jac, jacDet), i.e.
            the output of self._constructForwardMap(uPupil, vPupil, ...)
            If not None, the mask is mapped to the image plane.
            (the default is None)
        """
        # Center the pupil coordinates on the circle's center
        uPupilCen = uPupil - uPupilCirc
        vPupilCen = vPupil - vPupilCirc

        # The pixel scale in normalized coordinates is the inverse of the donut radius
        pixelScale = 1 / self.instrument.donutRadius

        # If a forward map is provided, begin preparing for mapping the mask
        # to the image plane
        if fwdMap is not None:
            uImage, vImage, jac, jacDet = fwdMap

            # Calculate quantities for the forward map
            invJac = np.array(
                [
                    [+jac[1, 1], -jac[0, 1]],  # type: ignore
                    [-jac[1, 0], +jac[0, 0]],  # type: ignore
                ]
            )
            invJac /= jacDet

            # Use a local linear approximation to center the image coordinates
            uImageCen = (
                uImage - jac[0, 0] * uPupilCirc - jac[0, 1] * vPupilCirc
            )
            vImageCen = (
                vImage - jac[1, 0] * uPupilCirc - jac[1, 1] * vPupilCirc
            )

            # Calculate the diagonal distance across each pixel on the pupil
            diagL = np.sqrt(
                (invJac[0, 0] + invJac[0, 1]) ** 2  # type: ignore
                + (invJac[1, 0] + invJac[1, 1]) ** 2  # type: ignore
            )
            diagL *= pixelScale

        else:
            # Use the pupil coordinates as the image coordinates
            uImageCen = uPupilCen
            vImageCen = vPupilCen

            # Diagonal distance across a regular pixel
            diagL = np.sqrt(2) * pixelScale

        # Assign pixels to groups based on whether they're definitely
        # inside/outside the circle, or on the border
        rPupilCen = np.sqrt(uPupilCen**2 + vPupilCen**2)
        inside = rPupilCen < (rPupilCirc - diagL / 2)
        outside = rPupilCen > (rPupilCirc + diagL / 2)
        border = ~(inside | outside)

        # We can go ahead and assign fractional mask 1 (0) to pixels
        # totally inside (outside) the circle
        out = np.zeros_like(uPupil)
        out[inside] = 1
        out[outside] = 0

        # If nothing is on the border, go ahead and return the mask
        if not border.any():
            return out

        # Calculate coefficients for the line (y = m*x + b) that is tangent to
        # the circle where the ray that passes through each point intersects the
        # circle (in pupil coordinates)
        uPupilCen, vPupilCen = uPupilCen[border], vPupilCen[border]
        m = -uPupilCen / vPupilCen  # slope
        b = (
            np.sqrt(uPupilCen**2 + vPupilCen**2) * rPupilCirc / vPupilCen
        )  # intercept

        # Select the border image coordinates
        uImageCen, vImageCen = uImageCen[border], vImageCen[border]

        if fwdMap is not None:
            # Transform the slope and intercept to image coordinates
            invJac = invJac[..., border]  # type: ignore
            a1 = m * invJac[0, 0] - invJac[1, 0]
            a2 = m * uPupilCen + b - vPupilCen
            a3 = -m * invJac[0, 1] + invJac[1, 1]
            m = a1 / a3
            b = (a2 - a1 * uImageCen) / a3 + vImageCen

        # Use symmetry to map everything onto the situation where -1 <= mImage <= 0
        mask = m > 0
        uImageCen[mask] = -uImageCen[mask]
        m[mask] = -m[mask]

        mask = m < -1
        uImageCen[mask], vImageCen[mask] = vImageCen[mask], uImageCen[mask]
        m[mask], b[mask] = 1 / m[mask], -b[mask] / m[mask]

        # Calculate the v intercept on the right side of the pixel
        vStar = m * (uImageCen + pixelScale / 2) + b

        # Calculate the fractional distance of intercept from the top of the pixel
        gamma = (vImageCen + pixelScale / 2 - vStar) / pixelScale

        # Now determine illumination for border pixels
        borderOut = np.zeros_like(uPupilCen)

        # Pixels that are totally inside the circle
        mask = gamma < 0
        borderOut[mask] = 1

        # Pixels that are totally outside the circle
        mask = gamma > (1 - m)
        borderOut[mask] = 0

        # Pixels for which the circle crosses the left and bottom sides
        mask = (1 < gamma) & (gamma < (1 - m))
        borderOut[mask] = -0.5 / m[mask] * (1 - (gamma[mask] + m[mask])) ** 2

        # Pixels for which the circle crosses the left and right sides
        mask = (-m < gamma) & (gamma < 1)
        borderOut[mask] = 1 - gamma[mask] - m[mask] / 2

        # Pixels for which the circle crosses the top and right
        mask = (0 < gamma) & (gamma < -m)
        borderOut[mask] = 1 + 0.5 * gamma[mask] ** 2 / m[mask]

        # Values below the (centered) u axis need to be flipped
        mask = vImageCen < 0
        borderOut[mask] = 1 - borderOut[mask]

        # Put the border values into the global output array
        out[border] = borderOut

        return out

    def createPupilMask(
        self,
        donutStamp: DonutStamp,
        *,
        binary: bool = False,
    ) -> np.ndarray:
        """Create the pupil mask for the stamp.

        Parameters
        ----------
        donutStamp : DonutStamp
            A stamp object containing the metadata required for constructing the mask.
        binary : bool, optional
            Whether to return a binary mask. If False, a fractional mask is returned
            instead. (the default is False)

        Returns
        -------
        np.ndarray
            The pupil mask
        """
        # TODO: Generalize this to include other obscurations!

        # Get the pupil grid
        uPupil, vPupil = self.instrument.createPupilGrid()

        # Combine masks for primary rim and the obscuration
        primaryMask = self._maskWithCircle(uPupil, vPupil, 0, 0, 1)
        obscMask = self._maskWithCircle(
            uPupil, vPupil, 0, 0, self.instrument.obscuration
        )
        mask = np.min([primaryMask, 1 - obscMask], axis=0)

        if binary:
            mask = mask >= 0.5

        return mask

    def createImageMask(
        self,
        donutStamp: DonutStamp,
        zkCoeff: np.ndarray = np.zeros(1),
        *,
        binary: bool = False,
        _invMap: Optional[tuple] = None,
    ) -> np.ndarray:
        """Create the image mask for the stamp.

        Note the uImage and vImage arrays must be regular 2D grids, like what is
        be returned by np.meshgrid.

        Parameters
        ----------
        donutStamp : DonutStamp
            A stamp object containing the metadata required for constructing the mask.
        binary : bool, optional
            Whether to return a binary mask. If False, a fractional mask is returned
            instead. (the default is False)

        Returns
        -------
        np.ndarray
        """
        # TODO: Generalize this to include other obscurations!

        # Get the image grid inside the pupil
        uImage, vImage, inside = self._getImageGridInsidePupil(
            zkCoeff, donutStamp
        )

        # Get the inverse mapping from image plane to pupil plane
        if _invMap is None:
            # Construct the inverse mapping
            uPupil, vPupil, invJac, invJacDet = self._constructInverseMap(
                uImage[inside],
                vImage[inside],
                zkCoeff,
                donutStamp,
            )
        else:
            uPupil, vPupil, invJac, invJacDet = _invMap

        # Rearrange into the forward map
        jac = np.array(
            [
                [+invJac[1, 1], -invJac[0, 1]],  # type: ignore
                [-invJac[1, 0], +invJac[0, 0]],  # type: ignore
            ]
        )
        jac /= invJacDet
        jacDet = 1 / invJacDet

        # Package the forward mapping
        fwdMap = (uImage[inside], vImage[inside], jac, jacDet)

        # Combine masks for primary rim and the obscuration
        primaryMask = self._maskWithCircle(uPupil, vPupil, 0, 0, 1, fwdMap)
        obscMask = self._maskWithCircle(
            uPupil, vPupil, 0, 0, self.instrument.obscuration, fwdMap
        )
        maskFill = np.min([primaryMask, 1 - obscMask], axis=0)

        # Fill in the full mask
        mask = np.zeros_like(uImage)
        mask[inside] = maskFill

        if binary:
            mask = mask >= 0.5

        return mask

    def mapPupilToImage(
        self,
        donutStamp: DonutStamp,
        zkCoeff: np.ndarray = np.zeros(1),
    ) -> DonutStamp:
        """Map the pupil to the image plane.

        Parameters
        ----------
        donutStamp : DonutStamp
            A stamp object containing the metadata needed for the mapping.
            It is assumed that mapping the pupil to the image plane is meant
            to model the image contained in this stamp.
        zkCoeff : np.ndarray, optional
            The wavefront at the pupil, represented as Zernike coefficients
            in meters, for Noll indices >= 4. Note this is in addition to
            the intrinsic wavefront aberration.
            (the default is zero)

        Returns
        -------
        DonutStamp
            The stamp object mapped to the image plane.
        """
        # Make a copy of the stamp
        stamp = donutStamp.copy()

        # Get the image grid inside the pupil
        uImage, vImage, inside = self._getImageGridInsidePupil(zkCoeff, stamp)

        # Construct the inverse mapping
        uPupil, vPupil, jac, jacDet = self._constructInverseMap(
            uImage[inside],
            vImage[inside],
            zkCoeff,
            stamp,
        )

        # Create the image mask
        mask = self.createImageMask(
            stamp, zkCoeff, _invMap=(uPupil, vPupil, jac, jacDet)
        )

        # Fill the image (this assumes that, except for vignetting,
        # the pupil is uniformly illuminated)
        stamp.image = np.zeros_like(stamp.image)
        stamp.image[inside] = mask[inside] * jacDet

        return stamp

    def mapImageToPupil(
        self,
        donutStamp: DonutStamp,
        zkCoeff: np.ndarray = np.zeros(1),
    ) -> DonutStamp:
        """Map a stamp from the image to the pupil plane.

        Parameters
        ----------
        donutStamp : DonutStamp
            A stamp object containing the array to be mapped from the image
            to the pupil plane, plus the required metadata.
        zkCoeff : np.ndarray, optional
            The wavefront at the pupil, represented as Zernike coefficients
            in meters, for Noll indices >= 4. Note this is in addition to
            the intrinsic wavefront aberration.
            (the default is zero)

        Returns
        -------
        DonutStamp
            The stamp object mapped to the image plane.
        """
        # Make a copy of the stamp
        stamp = donutStamp.copy()

        # Create regular pupil and image grids
        uPupil, vPupil = self.instrument.createPupilGrid()
        uImage, vImage = self.instrument.createImageGrid(stamp.image.shape[0])

        # Construct the forward mapping
        uImageMap, vImageMap, jac, jacDet = self._constructForwardMap(
            uPupil,
            vPupil,
            zkCoeff,
            stamp,
        )

        # Interpolate the array onto the pupil plane
        pupil = interpn(
            (vImage[:, 0], uImage[0, :]),
            stamp.image,
            (vImageMap, uImageMap),
            method="linear",
            bounds_error=False,
        )
        pupil *= jacDet

        # Set NaNs to zero
        pupil = np.nan_to_num(pupil)

        # Mask the pupil
        mask = self.createPupilMask(stamp)
        pupil *= mask

        # Update the stamp with the new pupil image
        stamp.image = pupil

        return stamp
